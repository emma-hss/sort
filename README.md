## 前言
个人博客：https://blog.csdn.net/weixin_41635305

排序算法，博大精深啊，大家有啥问题，欢迎打扰，尽我所能回答，欢迎Star，star，star。

# 冒泡排序
**1.冒泡排序中心思想**：
①冒泡排序（Bubble Sort）是一种**简单的排序算法**。

②它重复地遍历要排序的数列，**一次比较两个元素**，如果他们的顺序错误就把他们交换过来。

③遍历数列的工作是重复地进行**直到没有再需要交换**，也就是说该数列已经排序完成。

④这个算法的名字由来是因为越小的元素会经由交换慢**慢“浮”到数列的顶端**。


**2.运算流程**：
<1>.比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。

<2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

<3>.针对所有的元素重复以上的步骤，除了最后一个。

<4>.持续每次对越来越少的元素重复上面1-3的步骤，直到没有任何一对数字需要比较。


**3.动图演示**：
有2份源码：（资源来自网络）
一份是JavaScript实现的源码
另一份是用numpy+opencv实现的动态效果图，需要下载：numpy，opencv-python
(执行速度可以自己调整，小编已经实现过代码，效果很棒哦)

**动图配合着代码一起看效果更佳哦！！**
https://img-blog.csdnimg.cn/20190302222532241.gif

**过程白话说明**：从左开始第一对来对比数值，如果第一个比第二个大（升序），就交换他们两个，再让第二个值与第三个值对比，持续每次对越来越少的元素重复上面的步骤，最后的元素会是最大的数。（**两两对比大在右**）

**4.Python代码如下：**
```
def bubble_sort(alist):
    for j in range(len(alist)-1,0,-1):
        # j表示每次遍历需要比较的次数，是逐渐减小的
        for i in range(j):
            if alist[i] > alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]
li = [54,26,93,17,77,31,44,55,20]
bubble_sort(li)
print(li)
```


**5.改进方法思路**：
传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。


**6.算法分析**
最好情况：T(n) = O(n)，即当输入的数据已经是正序时
最坏情况：T(n) = O(n2)，即当输入的数据是反序时
平均时间复杂度：T(n) = O(n2)
空间复杂度：T(n) = O(1)
排序方式：In-place，即占用常数内存(不占用额外内存)
稳定性：稳定
数值变化：n值小时比较好
面试考点：时间复杂度/比较次数/单轮冒泡（仅供参考）



文章参考来源如下：
https://www.cnblogs.com/jztan/p/5878630.html
https://blog.csdn.net/han_xiaoyang/article/details/12163251
微信公众号：恋习python

（如有任何请联系小编）
